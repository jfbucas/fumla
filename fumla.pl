#!/usr/bin/perl -w

#
#	Usage: fumla.pl URL mount_point
#
#	URL is pointing to a Joomla website and can be of the following forms
#		http://joomla.eg/administrator
#		https://joomla.eg/administrator/
#		https://fumla@joomla.eg/administrator
#		https://fumla:passwd@joomla.eg/administrator/
#
#


use strict;
use warnings;

use threads;
use threads::shared;

use Fuse;
use POSIX qw(ENOENT EISDIR EINVAL);

use WWW::Mechanize;
use HTTP::Cookies;

use Term::Prompt;


#---------------------------------------------------
# Website settings
my $url = '';
my $username = '';
my $password = '';
my $userid = '';

#---------------------------------------------------
# The Mechanize for you
my $m = WWW::Mechanize->new();

# Global scalars used for HTTP queries
my $code;	# Joomla auth code
my $page;
my $response;

my $sectionid=-1;
my $catid=-1;
my $articleid=-1;

my %sections;
my %categories;
my %articles;

#---------------------------------------------------
# Joomla access functions

# Connect to the website
sub fumla_connect() {
	print "Connecting\n";
	$m->get($url);

	# Get the uniq Code generated by Joomla
	$page = $m->content();
	for ($page =~ /type=\"hidden\" name=\"([^"]*)\" value=\"1\" \/>/smi){
		$code = $1;
	}

	# Submit Auth info
	print "Authenticating\n";
	$response = $m->submit_form(
		form_id => 'form-login',
		fields	=> {	'username'	=>  $username,
				'passwd'	=>  $password,
				'option'	=>  'com_login',
				'task'		=>  'login',
				$code		=>  '1',
				'lang'		=>  'en-GB'
			}
	);
	die "Couldn't pass login form" unless $response->is_success;
}


# Get Section list
sub get_sections() {
	(%sections) = ( '.' => {
				type => 0040,
				mode => 0755,
				ctime => time()-1000,
				sectionid => -1
			} );

	$sections{ '..' }  = {
				type => 0040,
				mode => 0755,
				ctime => time()-1000,
				sectionid => -1
			};


	$m->get($url . "index.php?option=com_sections&scope=content&limit=0" );
	$page = $m->content();

	while ($page =~ /<a href="index.php\?option=com_sections&amp;scope=content&amp;task=edit&amp;cid\[\]=([^"]*)">[\t\n ]*([^<]*)<\/a>/g ){
		print $1 . " // " . $2 . "\n";
		
		$sections { "$2" } = {
					type => 0040,
					mode => 0755,
					ctime => time()-1000,
					sectionid => $1
				} ;
	}

	return %sections;
}

# Get Categories list ( sectionid )
sub get_categories {

	print "Get Categories\n";
	my $sectionid = shift;
	(%categories) = ( 
		'.' => {
			type => 0040,
			mode => 0755,
			ctime => time()-1000,
			catid => -1
		}
	);
	$categories { '..' } = {
				type => 0040,
				mode => 0755,
				ctime => time()-1000,
				sectionid => $sectionid
	};
	$m->get($url . "index.php?option=com_categories&section=com_content&limit=0&sectionid=" . $sectionid );
	#print $m->content();
	$page = $m->content();

	while ($page =~ /<a href="index.php\?option=com_categories&amp;section=com_content&amp;task=edit&amp;cid\[\]=(.*)&amp;type=content">[\t\n ]*([^<]*)<\/a>/g ){
		#print $1 . " || " . $2 . "\n";

		$categories { "$2" } = {
					type => 0040,
					mode => 0755,
					ctime => time()-1000,
					catid => $1
				} ;	
	}

	return %categories;
}

# Get Articles list ( sectionid, catid )
sub get_articles {

	my $sectionid = shift;
	my $catid = shift;
	(%articles) = ( 
		'.' => {
			type => 0040,
			mode => 0755,
			ctime => time()-1000,
			cid => -1
		}
	);
	$articles { '..' } = {
				type => 0040,
				mode => 0755,
				ctime => time()-1000,
				catid => $catid
	};
	$m->get($url . "index.php?option=com_content&limit=0&sectionid=$sectionid&catid=$catid" );
	#print $m->content();
	$page = $m->content();

	while ($page =~ /<a href="index.php\?option=com_content&amp;sectionid=$sectionid&amp;task=edit&amp;cid\[\]=([^"]*)">[\t\n ]*([^<]*)<\/a>/g ){
	#while ($page =~ /<tr class="row[01]">.*<a href="index.php\?option=com_content&amp;sectionid=1&amp;task=edit&amp;cid\[\]=([^"]*)">[\t\n ]*([^<]*)<\/a>.*<td nowrap="nowrap">(.*)<\/td>.*<\/tr>/gs ){
		my $cid = $1;
		my $name = $2;
		print $cid . " <> " . $name . "\n";
		while ( exists( $articles{ "$name" } ) ) {
			$name = $name . "_";
		}
		$articles { "$name" } = {
					cont => "fumla",
					type => 0100,
					mode => 0644,
					ctime => time()-1000,
					cid => $cid
				} ;	
			
	}
	# Date of article
	if ( 0 ) {
	while ($page =~ /<td nowrap="nowrap">[ \t\n]*([0-9\.]*)[ \t\n]*<\/td>/g ){
		print $1 . "\n";
		#$articleid = $1;
		#$articlename = $2;
	}}
	
	return %articles;
}

# Get Article Content ( cid )
sub get_article_content {

	my $cid = shift;
	print "Getcontent of " . $cid . "\n";

	$m->get($url . "index.php?option=com_content&task=edit&sectionid=-1&cid[]=" . $cid );
	$page = $m->content();
	# unlock the article
	$response = $m->submit_form(
		form_name => 'adminForm',
		fields	=> {
				'task'		=>  'cancel',
				$code		=>  '1'
			}
	);

	if ( $page =~ /<textarea name="text"[^>]*>(.*?)<\/textarea>/gs ) {
		my $content = $1;
		$content =~ s/&lt;/</g;
		$content =~ s/&gt;/>/g;
		$content =~ s/&quot;/"/g;
		$content =~ s/&amp;/&/g;
		return $content;
	}
	return "";
}

# Create Article ( sectionid catid name )
sub create_article {

	my ($sectionid, $catid, $name)  = (@_);
	my $savecode;

	$name =~ s/&/&amp;/g;

	my $alias = $name;
	$alias =~ s/ //g;
	$alias =~ s/&/&amp;/g;
	$alias =~ s/&/&amp;/g;
	print "Create Article " . $name . " in sectionid " . $sectionid . "|catid " . $catid . "\n";

	$m->get($url . "index.php?option=com_content&task=add&sectionid=". $sectionid ."&catid=" . $catid );
	# Get the uniq Code generated by Joomla
	$page = $m->content();
	for ($page =~ /type=\"hidden\" name=\"([^"]*)\" value=\"1\" \/>/smi){
		$savecode = $1;
	}

	$response = $m->submit_form(
		form_name => 'adminForm',
		fields	=> {
				'title'		=>  $name,
				'state'		=>  "1",
				'alias'		=>  $name,
				'frontpage'	=>  "0",
				'sectionid'	=>  $sectionid,
				'catid'		=>  $catid,
				'text'		=>  "EmptyTextForAStart", # articles cannot be empty
#				'details[created_by]'		=>  $userid,
				'option'	=>  'com_content',
				'task'		=>  'save',
				'cid[]'		=>  '',
				'id'		=>  '',
				'version'	=>  '0',
				'mask'		=>  '0',
				$savecode	=>  '1'
			}
	);
	
	return "";
}

# Edit Article ( cid text )
sub edit_article {

	my ($cid, $text)  = (@_);
	my $savecode;

	print "Edit Article " . $cid . "\n";

	$m->get($url . "index.php?option=com_content&task=edit&sectionid=-1&cid[]=" . $cid );
	# Get the uniq Code generated by Joomla
	$page = $m->content();
	for ($page =~ /type=\"hidden\" name=\"([^"]*)\" value=\"1\" \/>/smi){
		$savecode = $1;
	}

	$response = $m->submit_form(
		form_name => 'adminForm',
		fields	=> {
				'text'		=>  $text, # articles cannot be empty
				'task'		=>  'save',
				$savecode	=>  '1'
			}
	);
	
	return "";
}

#---------------------------------------------------
# Fuse functions

# Fix the name
sub filename_fixup {
	my ($file) = shift;
	$file =~ s,^/,,;
	$file = '.' unless length($file);
	return $file;
}

sub e_getattr {
	my ($file) = filename_fixup(shift);
	$file =~ s,^/,,;
	$file = '.' unless length($file);
	print "getattr of ${file} \n";
	my @name = split(/\//, $file);
	my $level = @name;
	print "  level=$level : ";
	foreach (@name) {
		print("-" . $_ . "-");
	}
	print "\n";

	if (( $level == 0 ) || ( $name[0] eq "." )) {
		get_sections() unless exists( $sections{$name[0]} );
		return -ENOENT() unless exists( $sections{$name[0]} );
		my ($size) = 0;
		my ($modes) = ($sections{$name[0]}{type}<<9) + $sections{$name[0]}{mode};
		my ($dev, $ino, $rdev, $blocks, $gid, $uid, $nlink, $blksize) = (0,0,0,1,0,0,1,1024);
		my ($atime, $ctime, $mtime);
		$atime = $ctime = $mtime = $sections{$name[0]}{ctime};
		return ($dev,$ino,$modes,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);
	}

	if ( $level == 1 ) {
		get_sections() unless exists( $sections{$name[0]} );
		return -ENOENT() unless exists( $sections{$name[0]} );
		my ($size) = 0;
		my ($modes) = ($sections{$name[0]}{type}<<9) + $sections{$name[0]}{mode};
		my ($dev, $ino, $rdev, $blocks, $gid, $uid, $nlink, $blksize) = (0,0,0,1,0,0,1,1024);
		my ($atime, $ctime, $mtime);
		$atime = $ctime = $mtime = $sections{$name[0]}{ctime};
		return ($dev,$ino,$modes,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);
	}

	if ( $level == 2 ) {
		get_sections() unless exists( $sections{$name[0]} );
		return -ENOENT() unless exists( $sections{$name[0]} );
		get_categories( $sections{$name[0]}{ sectionid } ) unless exists( $categories{$name[1]} );
		return -ENOENT() unless exists( $categories{$name[1]} );
		my ($size) = exists($categories{$name[1]}{cont}) ? length($categories{$name[1]}{cont}) : 0;
		my ($modes) = ($categories{$name[1]}{type}<<9) + $categories{$name[1]}{mode};
		my ($dev, $ino, $rdev, $blocks, $gid, $uid, $nlink, $blksize) = (0,0,0,1,0,0,1,1024);
		my ($atime, $ctime, $mtime);
		$atime = $ctime = $mtime = $categories{$name[1]}{ctime};
		return ($dev,$ino,$modes,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);
	}

	if ( $level == 3 ) {
		get_sections() unless exists( $sections{$name[0]} );
		return -ENOENT() unless exists( $sections{$name[0]} );
		get_categories( $sections{$name[0]}{ sectionid } ) unless exists( $categories{$name[1]} );
		return -ENOENT() unless exists( $categories{$name[1]} );
		get_articles( $sections{$name[0]}{ sectionid }, $categories{$name[1]}{ catid }) unless exists( $articles{$name[2]} );
		return -ENOENT() unless exists( $articles{$name[2]} );
		
		if ( $articles{$name[2]}{cont} eq "fumla" ) {
			 # TODO - Check why cont  returns to fumla from time to time
			$articles{$name[2]}{cont} = get_article_content( $articles{$name[2]}{cid} );
		}
		
		my ($size) = exists($articles{$name[2]}{cont}) ? length($articles{$name[2]}{cont}) : 0;
		my ($modes) = ($articles{$name[2]}{type}<<9) + $articles{$name[2]}{mode};
		my ($dev, $ino, $rdev, $blocks, $gid, $uid, $nlink, $blksize) = (0,0,0,1,0,0,1,1024);
		my ($atime, $ctime, $mtime);
		$atime = $ctime = $mtime = $articles{$name[2]}{ctime};
		return ($dev,$ino,$modes,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);
	}
	return -ENOENT();
}

sub e_getdir {
	# return as many text filenames as you like, followed by the retval.
	my $dir = shift;
	$dir =~ s,^/,,;
	$dir = '/' unless length($dir);
	print("getdir called on ${dir}\n");
	my @name = split(/\//, $dir);
	my $level = @name;
	print "  level=$level : ";
	foreach (@name) {
		print("-" . $_ . "-");
	}
	print "\n";

	if ( $level == 0 ) {
		get_sections();
		#print %sec . "\n";
		#my $key;
		#my $value;
		#while (($key, $value) = each(%sec)){
		#	print $key." => ".$value."\n";
		#}
		return (keys %sections),0;
	}
	if ( $level == 1 ) {
		if ( exists( $sections{$name[0]} ) ) {
			if ( ! exists( $categories{".."} ) || exists( $categories{".."} ) && ($categories{".."}{ sectionid } != $sections{$name[0]}{ sectionid }) ) {
				get_categories( $sections{$name[0]}{ sectionid } );
			}
			return (keys %categories),0;
		}
		return (),0;
	} 
	if ( $level == 2 ) {
		if ( exists( $sections{$name[0]} ) && exists( $categories{$name[1]} ) ) {
			if ( ! exists( $articles{".."} ) || exists( $articles{".."} ) && ($articles{".."}{ catid } != $categories{$name[1]}{ catid }) ) {
				get_articles( $sections{$name[0]}{ sectionid }, $categories{$name[1]}{ catid } );
			}	
			return (keys %articles),0;
		}
		return (),0;
	}
	return (),0;
}



sub e_open {
	# VFS sanity check; it keeps all the necessary state, not much to do here.
	my ($file) = filename_fixup(shift);
	$file =~ s,^/,,;
	$file = '.' unless length($file);
	print("open called on ${file}\n");
	my @name = split(/\//, $file);
	my $level = @name;
	print "  level=$level : ";
	foreach (@name) {
		print("-" . $_ . "-");
	}
	print "\n";

	if ( $level < 3 ) {
		return -EISDIR();
	}
	if ( $level == 3 ) {

		get_sections() unless exists( $sections{$name[0]} );
		return -ENOENT() unless exists( $sections{$name[0]} );
		get_categories( $sections{$name[0]}{ sectionid } ) unless exists( $categories{$name[1]} );
		return -ENOENT() unless exists( $categories{$name[1]} );
		get_articles( $sections{$name[0]}{ sectionid }, $categories{$name[1]}{ catid }) unless exists( $articles{$name[2]} );
		return -ENOENT() unless exists( $articles{$name[2]} );

		print("open ok\n");
		return 0;
	}

	return -ENOENT();
}

sub e_read {
	# return an error numeric, or binary/text string.  (note: 0 means EOF, "0" will
	# give a byte (ascii "0") to the reading program)
	my ($file) = filename_fixup(shift);
	print("read called on ${file}\n");
	my @name = split(/\//, $file);
	my $level = @name;
	print "  level=$level : ";
	foreach (@name) {
		print("-" . $_ . "-");
	}
	print "\n";

	my ($buf,$off) = @_;
	if ( $level < 3 ) {
		return -EISDIR();
	}
	if ( $level == 3 ) {
		get_sections() unless exists( $sections{$name[0]} );
		return -ENOENT() unless exists( $sections{$name[0]} );
		get_categories( $sections{$name[0]}{ sectionid } ) unless exists( $categories{$name[1]} );
		return -ENOENT() unless exists( $categories{$name[1]} );
		get_articles( $sections{$name[0]}{ sectionid }, $categories{$name[1]}{ catid }) unless exists( $articles{$name[2]} );
		return -ENOENT() unless exists( $articles{$name[2]} );

		if ( $articles{$name[2]}{cont} eq "fumla" ) {
			$articles{$name[2]}{cont} = get_article_content( $articles{$name[2]}{cid} );
		}

		return -EINVAL() if $off > length($articles{$name[2]}{cont});
		return 0 if $off == length($articles{$name[2]}{cont});
		print("read ok\n");
		return substr($articles{$name[2]}{cont},$off,$buf);
	}
	return -ENOENT();
}

sub e_write {
	my ($file) = filename_fixup(shift);
	print("write called on ${file}\n");
	my @name = split(/\//, $file);
	my $level = @name;
	print "  level=$level : ";
	foreach (@name) {
		print("-" . $_ . "-");
	}
	print "\n";

	my ($buf,$off) = @_;
	if ( $level < 3 ) {
		return -EISDIR();
	}
	if ( $level == 3 ) {
		get_sections() unless exists( $sections{$name[0]} );
		return -ENOENT() unless exists( $sections{$name[0]} );
		get_categories( $sections{$name[0]}{ sectionid } ) unless exists( $categories{$name[1]} );
		return -ENOENT() unless exists( $categories{$name[1]} );
		get_articles( $sections{$name[0]}{ sectionid }, $categories{$name[1]}{ catid }) unless exists( $articles{$name[2]} );
		return -ENOENT() unless exists( $articles{$name[2]} );

		if ( $articles{$name[2]}{cont} eq "fumla" ) {
			$articles{$name[2]}{cont} = get_article_content( $articles{$name[2]}{cid} );
		}

		substr( $articles{$name[2]}{cont}, $off ) = $buf;
		if ( length($articles{$name[2]}{cont}) == 0 ) {
			$articles{$name[2]}{cont} = ".";
		}
		edit_article( $articles{$name[2]}{cid}, $articles{$name[2]}{cont} );
		
		return -EINVAL() if $off > length($articles{$name[2]}{cont});
		#return 0 if $off == length($articles{$name[2]}{cont});
		print("write ok\n");
		#return $off; #substr($articles{$name[2]}{cont},$off,$buf);
		return length($buf);
	}
	return -ENOENT();
}

sub e_truncate {
	my ($file) = filename_fixup(shift);
	print("truncate called on ${file}\n");
	my @name = split(/\//, $file);
	my $level = @name;
	print "  level=$level : ";
	foreach (@name) {
		print("-" . $_ . "-");
	}
	print "\n";

	my $off = shift;
	if ( $level < 3 ) {
		return -EISDIR();
	}
	if ( $level == 3 ) {
		get_sections() unless exists( $sections{$name[0]} );
		return -ENOENT() unless exists( $sections{$name[0]} );
		get_categories( $sections{$name[0]}{ sectionid } ) unless exists( $categories{$name[1]} );
		return -ENOENT() unless exists( $categories{$name[1]} );
		get_articles( $sections{$name[0]}{ sectionid }, $categories{$name[1]}{ catid }) unless exists( $articles{$name[2]} );
		return -ENOENT() unless exists( $articles{$name[2]} );

		if ( $articles{$name[2]}{cont} eq "fumla" ) {
			$articles{$name[2]}{cont} = get_article_content( $articles{$name[2]}{cid} );
		}

		return -EINVAL() if $off > length($articles{$name[2]}{cont});
		return 0 if $off == length($articles{$name[2]}{cont});

		$articles{$name[2]}{cont} = substr( $articles{$name[2]}{cont}, 0, $off );
		if ( length($articles{$name[2]}{cont}) == 0 ) {
			$articles{$name[2]}{cont} = ".";
		}
		edit_article( $articles{$name[2]}{cid}, $articles{$name[2]}{cont} );
		
		print("truncate ok\n");
		return 0;
	}
	return -ENOENT();
}

sub e_mknod  {
	my ($file, $modes, $dev) = @_;
	$file = filename_fixup($file);
	print("mknod called on ${file}\n");
	my @name = split(/\//, $file);
	my $level = @name;
	print "  level=$level : ";
	foreach (@name) {
		print("-" . $_ . "-");
	}
	print "\n";

	if ( $level <= 2 ) {
		return -EPERM();
	}

	if ( $level == 3 ) {
		get_sections() unless exists( $sections{$name[0]} );
		return -ENOENT() unless exists( $sections{$name[0]} );
		get_categories( $sections{$name[0]}{ sectionid } ) unless exists( $categories{$name[1]} );
		return -ENOENT() unless exists( $categories{$name[1]} );

		create_article( $sections{$name[0]}{ sectionid }, $categories{$name[1]}{ catid }, $name[2] );
		return 0;
		
	}
	return -EPERM();
}

sub e_utime {
	my ($file, $atime,$mtime) = @_;
	$file = filename_fixup($file);
	print("utime called on ${file}\n");
	my @name = split(/\//, $file);
	my $level = @name;
	print "  level=$level : ";
	foreach (@name) {
		print("-" . $_ . "-");
	}
	print "\n";

	return -ENOENT() unless $level > 2;
	return -ENOENT() unless exists($articles{ $name[2] });

	#$files{$file}{time} = $mtime;
	return 0;
}

sub e_statfs { return 255, 1, 1, 1, 1, 2 }


#---------------------------------------------------
# Main


# If you run the script directly, it will run fusermount, which will in turn
# re-run this script.  Hence the funky semantics.

my ($source) = "";
$source = shift(@ARGV) if @ARGV;

if ( $source =~ m,^(https?://[^@]*)$, ) {
	$url=$1;
} elsif ( $source =~ m,^(https?://)([^:]*)@(.*)$, ) {
	$username=$2;
	$url=$1.$3;
} elsif ( $source =~ m,^(https?://)([^:]*):([^:]*)@(.*)$, ) {
	$username=$2;
	$password=$3;
	$url=$1.$4;
}

if ( $username eq "" ) {
	$username = &prompt('x',"Username: ", "", "fumla");
}
if ( $password eq "" ) {
	$password = &prompt('p',"Password: ", "", "");
}

if ( $url =~ m,[^/]$, ) {
	$url .= "/";
}
	

my ($mountpoint) = "";
$mountpoint = shift(@ARGV) if @ARGV;

#print $mountpoint . "\n" . $source . "\n" .$url . "\n" . "$username" . "\n" . "$password" . "\n"; exit

# Establishes the connection to the web interface
fumla_connect();

Fuse::main(
	mountpoint=>$mountpoint,
	getattr =>"main::e_getattr",
	getdir  =>"main::e_getdir",
	open    =>"main::e_open",
	read    =>"main::e_read",
	write   =>"main::e_write",
	truncate=>"main::e_truncate",
	statfs  =>"main::e_statfs",
	mknod   =>"main::e_mknod",
	utime   =>"main::e_utime",
#	unlink  =>"main::e_unlink",
#	rename  =>"main::e_rename",
#	mkdir   =>"main::e_mkdir",
#	rmdir   =>"main::e_rmdir",
##	symlink =>"main::e_symlink",
##	link    =>"main::e_link",
##	chmod   =>"main::e_chmod",
##	chown   =>"main::e_chown",
	threaded=>0
);
